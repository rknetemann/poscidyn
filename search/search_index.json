{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Poscidyn in a nutshell","text":"<p>Poscidyn is a Python toolkit based on JAX, designed to streamline and accelerate common workflows in nonlinear oscillator dynamics. It enables the simulation and visualization of (nonlinear) oscillators using experimentally realistic setups, supporting both time- and frequency-domain analyses.</p> <p>Features include:</p> <ul> <li>Frequency sweeping (forward and backward)</li> <li>Vmappable (batched) frequency sweeping </li> <li>Built-in models of (nonlinear) oscillators</li> </ul>"},{"location":"#quick-example","title":"Quick example","text":"<pre><code>import poscidyn\nimport numpy as np\n\nQ, omega_0, alpha, gamma = np.array([100.0]), np.array([1.00]), np.zeros((1,1,1)), np.zeros((1,1,1,1))\ngamma[0,0,0,0] = 2.55\nmodal_forces = np.array([1.0])\n\ndriving_frequency = np.linspace(0.9, 1.3, 501)\ndriving_amplitude = np.linspace(0.1, 1.0, 10)\n\nMODEL = poscidyn.NonlinearOscillator(Q=Q, alpha=alpha, gamma=gamma, omega_0=omega_0)\nEXCITOR = poscidyn.OneToneExcitation(driving_frequency, driving_amplitude, modal_forces)\n\nfrequency_sweep = poscidyn.frequency_sweep(\n    model = MODEL, excitor=EXCITOR,\n) \n</code></pre>"},{"location":"#for-who-is-poscidyn","title":"For who is Poscidyn?","text":"<p>If you want to know more for who Poscidyn could be a useful package, have a look at the For who is Poscidyn? page.</p>"},{"location":"#credits-where-they-are-due","title":"Credits where they are due","text":"<p>JAX: a Python library for accelerator-oriented array computation and program transformation, designed for high-performance numerical computing and large-scale machine learning.</p> <p>Diffrax: JAX-based library providing numerical differential equation solvers.</p> <p>Equinox: your one-stop JAX library, for everything you need that isn't already in core JAX.</p>"},{"location":"for-who-is-poscidyn/","title":"For who is Poscidyn?","text":"<p>Poscidyn is primarily intended for users who need to simulate experimentally realistic time responses and frequency sweeps with minimal implementation overhead. The package is designed for applications where ease of use and computational speed are central requirements.</p> <p>Rather than serving as a general-purpose continuation or bifurcation analysis framework, Poscidyn focuses on simplifying common workflows in nonlinear oscillator dynamics. It provides ready-to-use abstractions for frequently used oscillator models, excitation types, solvers, and sweep strategies, allowing users to focus on analysis rather than numerical boilerplate.</p> <p>By handling many of the practical challenges associated with these simulations\u2014such as steady-state detection, sweep construction, and batching\u2014Poscidyn enables rapid experimentation and large-scale studies with only a small amount of user code.</p> <p>If Poscidyn does not include a specific model or excitation type required for your application, the package is designed to be extensible. The Extending Poscidyn section of the documentation explains how existing components can be adapted or expanded to fit custom use cases.</p>"},{"location":"for-who-is-poscidyn/#where-to-go-next","title":"Where to go next?","text":"<p>If this package aligns with your needs, the getting-started section walks through the initial steps of using Poscidyn. Begin with the Installation page to install the package and verify platform compatibility.</p>"},{"location":"where-poscidyn-shines/","title":"Where Poscidyn shines","text":""},{"location":"where-poscidyn-shines/#ease-of-use","title":"Ease of Use","text":"<p>Python is well known for its accessibility and readability, and this pythonic philosophy is consistently reflected throughout the package. Poscidyn is fully compatible with NumPy arrays, allowing practitioners to immediately leverage their existing knowledge and workflows without additional overhead.</p>"},{"location":"where-poscidyn-shines/#performance","title":"Performance","text":"<p>Poscidyn is implemented entirely using JAX, which enables all core functions to be seamlessly <code>jitted</code> and <code>vmapped</code>. While these features are not required for basic usage, users are strongly encouraged to consult the JAX documentation to fully unlock Poscidyn\u2019s performance potential.</p> <p>In practical terms, this design allows time-domain simulations and frequency sweeps to be batched and executed at scale very easily. As a result, Poscidyn is particularly well suited for applications where computational speed is essential.</p>"},{"location":"where-poscidyn-shines/#connection-to-machine-learning","title":"Connection to machine learning","text":"<p>Because Poscidyn is highly optimized for performance, it enables the efficient generation of large-scale dynamical datasets. Opening up a whole new world of data-driven applications such as training supervised learning models.</p>"},{"location":"api/methods/","title":"frequency_sweep","text":""},{"location":"api/methods/#poscidyn.frequency_sweep.frequency_sweep","title":"<code>frequency_sweep(model, excitor, sweeper=NearestNeighbourSweep(), solver=TimeIntegrationSolver(), multistarter=LinearResponseMultistart(), precision=const.Precision.SINGLE)</code>","text":"<p>Run a frequency sweep for a dynamical model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>AbstractOscillator</code> <p>...</p> required <code>excitor</code> <code>AbstractExcitation</code> <p>...</p> required <code>sweeper</code> <code>AbstractSweep</code> <p>...</p> <code>NearestNeighbourSweep()</code> <code>solver</code> <code>AbstractSolver</code> <p>...</p> <code>TimeIntegrationSolver()</code> <code>multistarter</code> <code>AbstractMultistart</code> <p>...</p> <code>LinearResponseMultistart()</code> <code>precision</code> <code>Precision</code> <p>...</p> <code>SINGLE</code> <p>Returns:</p> Type Description <code>FrequencySweepResult</code> <p>A <code>FrequencySweepResult</code> containing the sweep response.</p>"},{"location":"api/methods/#time_response","title":"time_response","text":""},{"location":"api/methods/#poscidyn.time_response.time_response","title":"<code>time_response(model, driving_frequency, driving_amplitude, initial_displacement, initial_velocity, solver=TimeIntegrationSolver(), precision=const.Precision.DOUBLE, **kwargs)</code>","text":"<p>Compute the time response of a dynamical model to a one-tone excitation.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>AbstractOscillator</code> <p>The dynamical model to simulate.</p> required <code>driving_frequency</code> <code>Array</code> <p>The driving frequency (shape: (1,)).</p> required <code>driving_amplitude</code> <code>Array</code> <p>The driving amplitude for each mode (shape: (n_modes,)).</p> required <code>initial_displacement</code> <code>Array</code> <p>The initial displacement for each mode (shape: (n_modes,)).</p> required <code>initial_velocity</code> <code>Array</code> <p>The initial velocity for each mode (shape: (n_modes,)).</p> required <code>solver</code> <code>AbstractSolver</code> <p>The time integration solver to use.</p> <code>TimeIntegrationSolver()</code> <code>precision</code> <code>Precision</code> <p>The numerical precision to use.</p> <code>DOUBLE</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the solver's time_response method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple (ts, xs, vs) where ts is the time array (shape: (n_steps,)),</p> <code>tuple</code> <p>xs is the displacement array (shape: (n_steps, n_modes)), and vs is the velocity array (shape: (n_steps, n_modes)).</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>You can install Poscidyn directly from PyPI using pip: <pre><code>pip install poscidyn\n</code></pre> Requirements:</p> <ul> <li>Python 3.10 or newer</li> </ul>"},{"location":"getting-started/installation/#virtual-environment","title":"Virtual environment","text":"<p>To avoid dependency conflicts with other Python packages, it is strongly recommended to install Poscidyn inside a virtual environment.</p>"},{"location":"getting-started/installation/#platform-specific-setup","title":"Platform specific setup","text":"<p>Below are examples for the most common platforms.</p> <p>It is recommended that you create a virtual environment before installing poscidyn in order to avoid potential conflicts with other packages. </p> WindowsLinux / macOS <pre><code>python -m venv .venv\n.venv\\Scripts\\activate\n</code></pre> <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre>"},{"location":"getting-started/installation/#compatibility","title":"Compatibility","text":"<p>The table below summarizes the supported platforms for Poscidyn.</p> <p>Compatibility is primarily determined by the availability of the JAX backend on each platform. As JAX continues to evolve, support for additional platforms may improve over time.</p> <p>Legend - <code>yes</code> \u2014 fully supported and verified - <code>yes*</code> \u2014 expected to work but not yet fully verified - <code>experimental*</code> \u2014 experimental support; functionality may be limited or unstable - <code>no</code> \u2014 not supported - <code>n/a</code> \u2014 not applicable</p> Platform Linux, x86_64 Linux, aarch64 Mac, aarch64 Windows, x86_64 Windows WSL2, x86_64 CPU yes yes* yes* yes* yes* NVIDIA GPU yes yes* n/a no experimental* Google Cloud TPU yes* n/a n/a n/a n/a AMD GPU yes* no n/a no experimental* Apple GPU n/a no experimental* n/a n/a Intel GPU experimental* n/a n/a no no"},{"location":"getting-started/limitations/","title":"Limitations","text":"<ul> <li> <p>Difference between parallel and embarassingly parallel and how for example increasing the multistart search space could seriously increase simulation time.</p> </li> <li> <p>Time integration solvers estimate the steady-state time, but are based on approximations and may require tuning of the time to steady state parameter to correctly calculate the maximum amplitude at different frequencies.</p> </li> <li> <p>Synthetically frequency sweeps do not reflect real world physics, and may therefor be inaccurate. </p> </li> <li> <p>Synthetic frequency sweeps currently do also not account for other complex solution branches.</p> </li> <li> <p>The built-in multistart method generates a grid of initial conditions based on the linear response amplitude of the system. As nonlinearities can significantly increase the amplitude of oscillation, this search space might be inaccurate, and could require manual tuning.</p> </li> </ul>"},{"location":"getting-started/understanding-poscidyn/","title":"Understanding Poscidyn","text":"<p>To get started with Poscidyn, there are only a few core concepts to understand. Poscidyn provides classes for selecting oscillator models (for example the Duffing oscillator or the Van der Pol oscillator), excitation models (for example single-tone or multi-tone excitation), and several advanced components such as solvers (e.g. time integration or shooting-method solvers), sweep methods (used to imitate continuation), and multistart methods (used to explore different initial conditions).</p> <p>These advanced classes may seem abstract at first. Therefore, it is important to first understand how Poscidyn operates conceptually, and how it compares to established continuation and bifurcation analysis software such as AUTO, MATCONT, and COCO.</p>"},{"location":"getting-started/understanding-poscidyn/#numerical-frequency-sweeping","title":"Numerical frequency sweeping","text":"<p>Frequency sweeps performed in an experimental setting typically involve slowly increasing the excitation frequency while allowing the system to reach steady state at each step. Once steady state is reached, the maximum oscillation amplitude is measured. It is crucial that this process is quasi-static: if the frequency step is too large, the system may jump to a different solution branch.</p> <p>In computational dynamics, this procedure is known as continuation. Software packages such as AUTO, MATCONT, and COCO are specifically designed for this purpose and have become cornerstone tools for analyzing bifurcations, limit cycles, frequency response curves, and many related phenomena.</p> <p>A major drawback of continuation methods is that they rely on sequential computations. Periodic orbits must be solved one after another in order to follow a solution branch, meaning that each computation depends on the previous one. This inherently limits parallelization and can result in long computation times.</p> <p>Poscidyn instead adopts a multistart approach, where steady-state periodic orbits are computed from a large set of initial conditions. While this approach requires significantly more computational resources, it can be much faster in practice because all simulations can be executed in parallel.</p> <p>This multistart strategy typically yields all solution branches simultaneously, meaning multiple solutions may exist for a single excitation frequency. In contrast, experimental frequency sweeps usually observe only a single branch. To bridge this gap, Poscidyn introduces artificial sweep methods. These methods synthetically reconstruct continuation-like behavior by selecting and ordering solutions from the high-dimensional multistart solution space.</p>"},{"location":"getting-started/understanding-poscidyn/#limitations","title":"Limitations","text":"<p>Be sure to consult the Limitations page, as these kinds of synthetic sweep methods come with important caveats and do not fully replicate true continuation algorithms.</p>"}]}