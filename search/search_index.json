{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Poscidyn in a nutshell","text":"<p>Poscidyn is a Python toolkit based on JAX, designed to streamline and accelerate common workflows in nonlinear oscillator dynamics. It enables the simulation and visualization of (nonlinear) oscillators using experimentally realistic setups, supporting both time- and frequency-domain analyses.</p> <p>Features include:</p> <ul> <li>Frequency sweeping (forward and backward)</li> <li>Vmappable (batched) frequency sweeping </li> <li>Built-in models of (nonlinear) oscillators</li> </ul>"},{"location":"#quick-example","title":"Quick example","text":"<pre><code>import poscidyn\nimport numpy as np\n\nQ, omega_0, alpha, gamma = np.array([100.0]), np.array([1.00]), np.zeros((1,1,1)), np.zeros((1,1,1,1))\ngamma[0,0,0,0] = 2.55\nmodal_forces = np.array([1.0])\n\ndriving_frequency = np.linspace(0.9, 1.3, 501)\ndriving_amplitude = np.linspace(0.1, 1.0, 10)\n\nMODEL = poscidyn.NonlinearOscillator(Q=Q, alpha=alpha, gamma=gamma, omega_0=omega_0)\nEXCITOR = poscidyn.OneToneExcitation(driving_frequency, driving_amplitude, modal_forces)\n\nfrequency_sweep = poscidyn.frequency_sweep(\n    model = MODEL, excitor=EXCITOR,\n) \n</code></pre>"},{"location":"#for-who-is-poscidyn","title":"For who is Poscidyn?","text":"<p>If you want to know more for who Poscidyn could be a useful package, have a look at the For who is Poscidyn? page.</p>"},{"location":"#credits-where-they-are-due","title":"Credits where they are due","text":"<p>JAX: a Python library for accelerator-oriented array computation and program transformation, designed for high-performance numerical computing and large-scale machine learning.</p> <p>Diffrax: JAX-based library providing numerical differential equation solvers.</p> <p>Equinox: your one-stop JAX library, for everything you need that isn't already in core JAX.</p>"},{"location":"for-who-is-poscidyn/","title":"For who is Poscidyn?","text":"<p>Poscidyn is primarily intended for users who need to simulate experimentally realistic time responses and frequency sweeps with minimal implementation overhead. The package is designed for applications where ease of use and computational speed are central requirements.</p> <p>Rather than serving as a general-purpose continuation or bifurcation analysis framework, Poscidyn focuses on simplifying common workflows in nonlinear oscillator dynamics. It provides ready-to-use abstractions for frequently used oscillator models, excitation types, solvers, and sweep strategies, allowing users to focus on analysis rather than numerical boilerplate.</p> <p>By handling many of the practical challenges associated with these simulations\u2014such as steady-state detection, sweep construction, and batching\u2014Poscidyn enables rapid experimentation and large-scale studies with only a small amount of user code.</p> <p>If Poscidyn does not include a specific model or excitation type required for your application, the package is designed to be extensible. The Extending Poscidyn section of the documentation explains how existing components can be adapted or expanded to fit custom use cases.</p>"},{"location":"for-who-is-poscidyn/#where-to-go-next","title":"Where to go next?","text":"<p>If this package aligns with your needs, the getting-started section walks through the initial steps of using Poscidyn. Begin with the Installation page to install the package and verify platform compatibility.</p>"},{"location":"future-work/","title":"Future work","text":"<p>Poscidyn is still under active development and has not yet reached its full potential. This page outlines the planned enhancements and long-term vision for the package.</p>"},{"location":"future-work/#planned-enhancements","title":"Planned Enhancements","text":"<ul> <li> <p>Oscillator models   Extension of the built-in model library to include additional canonical systems such as the Van der Pol, Lorenz, and Rayleigh oscillators.</p> </li> <li> <p>Parametric excitation   Support for parametric excitation mechanisms, enabling the study of parametrically driven systems.</p> </li> <li> <p>Solvers   Integration of additional solvers, including shooting methods and potentially standard continuation techniques, while preserving Poscidyn\u2019s ability to batch computations efficiently.</p> </li> <li> <p>Visualization tools   Built-in plotting and visualization utilities for common analyses, such as phase-space trajectories, frequency response curves, and time-domain responses.</p> </li> <li> <p>Sweep methods   Development of more physically motivated synthetic sweep strategies to better emulate experimental frequency sweep behavior for non-continuation methods.</p> </li> </ul>"},{"location":"future-work/#long-term-ideas","title":"Long-Term Ideas","text":"<ul> <li>Hybrid approaches   Combination of multistart batching with localized continuation methods, for example by segmenting sweeps and performing parallel continuations.</li> </ul>"},{"location":"future-work/#how-to-contribute","title":"How to Contribute","text":"<p>Contribution guidelines and development workflows will be documented in a future release.</p>"},{"location":"where-poscidyn-shines/","title":"Where Poscidyn shines","text":""},{"location":"where-poscidyn-shines/#ease-of-use","title":"Ease of Use","text":"<p>Python is well known for its accessibility and readability, and this pythonic philosophy is consistently reflected throughout the package. Poscidyn is fully compatible with NumPy arrays, allowing practitioners to immediately leverage their existing knowledge and workflows without additional overhead.</p>"},{"location":"where-poscidyn-shines/#performance","title":"Performance","text":"<p>Poscidyn is implemented entirely using JAX, which enables all core functions to be seamlessly <code>jitted</code> and <code>vmapped</code>. While these features are not required for basic usage, users are strongly encouraged to consult the JAX documentation to fully unlock Poscidyn\u2019s performance potential.</p> <p>In practical terms, this design allows time-domain simulations and frequency sweeps to be batched and executed at scale very easily. As a result, Poscidyn is particularly well suited for applications where computational speed is essential.</p>"},{"location":"where-poscidyn-shines/#connection-to-machine-learning","title":"Connection to machine learning","text":"<p>Because Poscidyn is highly optimized for performance, it enables the efficient generation of large-scale dynamical datasets. Opening up a whole new world of data-driven applications such as training supervised learning models.</p>"},{"location":"api/methods/","title":"frequency_sweep","text":""},{"location":"api/methods/#poscidyn.frequency_sweep.frequency_sweep","title":"<code>frequency_sweep(model, excitor, sweeper=NearestNeighbourSweep(), solver=TimeIntegrationSolver(), multistarter=LinearResponseMultistart(), precision=const.Precision.SINGLE)</code>","text":"<p>Run a frequency sweep for a dynamical model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>AbstractOscillator</code> <p>...</p> required <code>excitor</code> <code>AbstractExcitation</code> <p>...</p> required <code>sweeper</code> <code>AbstractSweep</code> <p>...</p> <code>NearestNeighbourSweep()</code> <code>solver</code> <code>AbstractSolver</code> <p>...</p> <code>TimeIntegrationSolver()</code> <code>multistarter</code> <code>AbstractMultistart</code> <p>...</p> <code>LinearResponseMultistart()</code> <code>precision</code> <code>Precision</code> <p>...</p> <code>SINGLE</code> <p>Returns:</p> Type Description <code>FrequencySweepResult</code> <p>A <code>FrequencySweepResult</code> containing the sweep response.</p>"},{"location":"api/methods/#time_response","title":"time_response","text":""},{"location":"api/methods/#poscidyn.time_response.time_response","title":"<code>time_response(model, driving_frequency, driving_amplitude, initial_displacement, initial_velocity, solver=TimeIntegrationSolver(), precision=const.Precision.DOUBLE, **kwargs)</code>","text":"<p>Compute the time response of a dynamical model to a one-tone excitation.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>AbstractOscillator</code> <p>The dynamical model to simulate.</p> required <code>driving_frequency</code> <code>Array</code> <p>The driving frequency (shape: (1,)).</p> required <code>driving_amplitude</code> <code>Array</code> <p>The driving amplitude for each mode (shape: (n_modes,)).</p> required <code>initial_displacement</code> <code>Array</code> <p>The initial displacement for each mode (shape: (n_modes,)).</p> required <code>initial_velocity</code> <code>Array</code> <p>The initial velocity for each mode (shape: (n_modes,)).</p> required <code>solver</code> <code>AbstractSolver</code> <p>The time integration solver to use.</p> <code>TimeIntegrationSolver()</code> <code>precision</code> <code>Precision</code> <p>The numerical precision to use.</p> <code>DOUBLE</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the solver's time_response method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple (ts, xs, vs) where ts is the time array (shape: (n_steps,)),</p> <code>tuple</code> <p>xs is the displacement array (shape: (n_steps, n_modes)), and vs is the velocity array (shape: (n_steps, n_modes)).</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>You can install Poscidyn directly from PyPI using pip: <pre><code>pip install poscidyn\n</code></pre> Requirements:</p> <ul> <li>Python 3.10 or newer</li> </ul>"},{"location":"getting-started/installation/#virtual-environment","title":"Virtual environment","text":"<p>To avoid dependency conflicts with other Python packages, it is strongly recommended to install Poscidyn inside a virtual environment.</p>"},{"location":"getting-started/installation/#platform-specific-setup","title":"Platform specific setup","text":"<p>Below are examples for the most common platforms.</p> <p>It is recommended that you create a virtual environment before installing poscidyn in order to avoid potential conflicts with other packages. </p> WindowsLinux / macOS <pre><code>python -m venv .venv\n.venv\\Scripts\\activate\n</code></pre> <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre>"},{"location":"getting-started/installation/#compatibility","title":"Compatibility","text":"<p>The table below summarizes the supported platforms for Poscidyn.</p> <p>Compatibility is primarily determined by the availability of the JAX backend on each platform. As JAX continues to evolve, support for additional platforms may improve over time.</p> <p>Legend - <code>yes</code> \u2014 fully supported and verified - <code>yes*</code> \u2014 expected to work but not yet fully verified - <code>experimental*</code> \u2014 experimental support; functionality may be limited or unstable - <code>no</code> \u2014 not supported - <code>n/a</code> \u2014 not applicable</p> Platform Linux, x86_64 Linux, aarch64 Mac, aarch64 Windows, x86_64 Windows WSL2, x86_64 CPU yes yes* yes* yes* yes* NVIDIA GPU yes yes* n/a no experimental* Google Cloud TPU yes* n/a n/a n/a n/a AMD GPU yes* no n/a no experimental* Apple GPU n/a no experimental* n/a n/a Intel GPU experimental* n/a n/a no no"},{"location":"getting-started/limitations/","title":"Limitations","text":"<p>Poscidyn has limitations, please make sure to read them before using this library for your application:</p> <ul> <li> <p>Difference between parallel and embarassingly parallel and how for example increasing the multistart search space could seriously increase simulation time.</p> </li> <li> <p>Time integration solvers estimate the steady-state time, but are based on approximations and may require tuning of the time to steady state parameter to correctly calculate the maximum amplitude at different frequencies.</p> </li> <li> <p>Synthetically frequency sweeps do not reflect real world physics, and may therefor be inaccurate. </p> </li> <li> <p>Synthetic frequency sweeps currently do also not account for other complex solution branches.</p> </li> <li> <p>The built-in multistart method generates a grid of initial conditions based on the linear response amplitude of the system. As nonlinearities can significantly increase the amplitude of oscillation, this search space might be inaccurate, and could require manual tuning.</p> </li> </ul>"},{"location":"getting-started/next-steps/","title":"Next steps","text":"<p>Now that you have installed Poscidyn, understand its core concepts, and reviewed the limitations, here\u2019s a suggested path to get productive quickly.</p>"},{"location":"getting-started/next-steps/#basic-usage","title":"Basic usage","text":"<p>Keep the mental model from Understanding Poscidyn in mind: pick an oscillator model, choose an excitation model, and decide whether you want a time response or a frequency sweep.</p> <p>Walk through the Basic usage pages in order:</p> <ol> <li>Oscillator models</li> <li>Excitation models</li> <li>Time response</li> <li>Frequency sweep</li> </ol> <p>Recommended</p> <p>Check out the Examples page, it will not only make the usage of Poscidyn more clear, but also demonstrates some of the use cases of using Poscidyn (such as generating large datasets).</p>"},{"location":"getting-started/next-steps/#avanced-usage","title":"Avanced usage","text":"<p>Once you have got the hang of the basic usage, move on to Advanced usage to explore Poscidyn's advanced (but still simple and powerfull) features:</p> <ul> <li>Choosing a solver</li> <li>Configuring multistart strategies</li> <li>Configuring sweep methods</li> </ul>"},{"location":"getting-started/next-steps/#extending-poscidyn","title":"Extending Poscidyn","text":"<p>If built-in components are not enough, see Extending Poscidyn to add custom models or excitation types.</p>"},{"location":"getting-started/understanding-poscidyn/","title":"Understanding Poscidyn","text":"<p>To get started with Poscidyn, there are only a few core concepts to understand. Poscidyn provides classes for selecting oscillator models (for example the Duffing oscillator or the Van der Pol oscillator), excitation models (for example single-tone or multi-tone excitation), and several advanced components such as solvers (e.g. time integration or shooting-method solvers), sweep methods (used to imitate continuation), and multistart methods (used to explore different initial conditions).</p> <p>These advanced classes may seem abstract at first. Therefore, it is important to first understand how Poscidyn operates conceptually, and how it compares to established continuation and bifurcation analysis software such as AUTO, MATCONT, and COCO.</p>"},{"location":"getting-started/understanding-poscidyn/#numerical-frequency-sweeping","title":"Numerical frequency sweeping","text":"<p>Frequency sweeps performed in an experimental setting typically involve slowly increasing the excitation frequency while allowing the system to reach steady state at each step. Once steady state is reached, the maximum oscillation amplitude is measured. It is crucial that this process is quasi-static: if the frequency step is too large, the system may jump to a different solution branch.</p> <p>In computational dynamics, this procedure is known as continuation. Software packages such as AUTO, MATCONT, and COCO are specifically designed for this purpose and have become cornerstone tools for analyzing bifurcations, limit cycles, frequency response curves, and many related phenomena.</p> <p>A major drawback of continuation methods is that they rely on sequential computations. Periodic orbits must be solved one after another in order to follow a solution branch, meaning that each computation depends on the previous one. This inherently limits parallelization and can result in long computation times.</p> <p>Poscidyn instead adopts a multistart approach, where steady-state periodic orbits are computed from a large set of initial conditions. While this approach requires significantly more computational resources, it can be much faster in practice because all simulations can be executed in parallel.</p> <p>This multistart strategy typically yields all solution branches simultaneously, meaning multiple solutions may exist for a single excitation frequency. In contrast, experimental frequency sweeps usually observe only a single branch. To bridge this gap, Poscidyn introduces artificial sweep methods. These methods synthetically reconstruct continuation-like behavior by selecting and ordering solutions from the high-dimensional multistart solution space.</p>"},{"location":"getting-started/understanding-poscidyn/#limitations","title":"Limitations","text":"<p>Be sure to consult the Limitations page, as these kinds of synthetic sweep methods come with important caveats and do not fully replicate true continuation algorithms.</p>"},{"location":"usage/basic-usage/oscillator-models/","title":"Setting up an oscillator model","text":"<p>Let's start by choosing an oscillator model. Poscidyn has multiple built in oscillator models. The full list of models is available on the Oscillator models page.</p> <p>Note</p> <p>Did you extend Poscidyn using your own oscillator, please contribute to the project by doing a pull request. Have a look at the Contributing page.</p>"},{"location":"usage/basic-usage/oscillator-models/#single-dof-harmonic-oscillator","title":"Single DOF Harmonic Oscillator","text":"<p>To keep things simple we will setup a simple linear harmonic oscillator first. Each model requires their own set of parameters to be initialized. In the case of a the harmonic oscillator that are the damping ratio \\(\\zeta\\), resonance frequency \\(\\omega_0\\) and cubic  stiffness \\(\\gamma\\):</p> \\[ \\ddot x   + 2\\zeta \\omega_0\\, \\dot x   + \\omega_0^{2}\\, x   \\;=\\; f         \\cos\\!\\left(\\omega t\\right). \\] <p>We begin by importing the necessary libraries: <pre><code>import numpy as np\nimport poscidyn\n</code></pre></p> <p>We then define the parameters of our system: <pre><code>zeta = np.array([0.01])\nomega_0 = np.array([1.0])\ndriving_frequency = np.linspace(0.5, 2.0, 500)\ndriving_amplitude = np.linspace(0.1, 1.0, 10)\n</code></pre></p> <p>Note</p> <p>It may seem confusing at first swhy we are using arrays here, that will become clear once we use this same system for multiple degrees of freedom.</p> <p>The last thing to do is initialize the model:</p> <pre><code>model = poscidyn.HarmonicOscillator(zeta=zeta, omega_0=omega_0)\n</code></pre> <p>That's it! Though the process of setting up a model, differs a little bit per model. So make sure to have a look at the documentation of each model to get started using it quickly.</p>"},{"location":"usage/basic-usage/oscillator-models/#multiple-dof-harmonic-oscillator","title":"Multiple DOF Harmonic Oscillator","text":"<p>For demonstration purposes, let's also see how we can use the same model for multiple degrees of freedom simulations.</p> \\[ \\begin{aligned} \\ddot x_1 &amp;+ 2\\zeta_1 \\omega_1\\, \\dot x_1 + \\omega_1^{2}\\, x_1 + c_{12}\\,(\\dot x_1 - \\dot x_2) + k_{12}\\,(x_1 - x_2) = f_1 \\cos(\\omega t + \\phi_1), \\\\[6pt] \\ddot x_2 &amp;+ 2\\zeta_2 \\omega_2\\, \\dot x_2 + \\omega_2^{2}\\, x_2 + c_{12}\\,(\\dot x_2 - \\dot x_1) + k_{12}\\,(x_2 - x_1) = f_2 \\cos(\\omega t + \\phi_2) . \\end{aligned} \\] <p>We begin by importing the necessary libraries: <pre><code>import numpy as np\nimport poscidyn\n</code></pre></p> <p>We then define the parameters of our system: <pre><code>zeta = np.array([0.01])\nomega_0 = np.array([1.0])\ndriving_frequency = np.linspace(0.5, 2.0, 500)\ndriving_amplitude = np.linspace(0.1, 1.0, 10)\n</code></pre></p> <p>The last thing to do is initialize the model:</p> <pre><code>model = poscidyn.HarmonicOscillator(zeta=zeta, omega_0=omega_0)\n</code></pre>"}]}